/* Generated by Phoenix Tuner X */
package frc.robot.subsystems;

import static edu.wpi.first.units.Units.*;

import com.ctre.phoenix6.CANBus;
import com.ctre.phoenix6.controls.SingleFadeAnimation;
import com.ctre.phoenix6.controls.SolidColor;
import com.ctre.phoenix6.controls.StrobeAnimation;
import com.ctre.phoenix6.hardware.CANdle;
import com.ctre.phoenix6.signals.RGBWColor;
import edu.wpi.first.math.geometry.Translation2d;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.networktables.GenericEntry;
import edu.wpi.first.wpilibj.shuffleboard.BuiltInWidgets;
import edu.wpi.first.wpilibj.shuffleboard.Shuffleboard;
import edu.wpi.first.wpilibj.shuffleboard.ShuffleboardTab;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.subsystems.drive.Drive;

public class LEDSubsystem extends SubsystemBase {
  private final CANBus kCANBus = new CANBus("rio");
  private final CANdle m_candle = new CANdle(60, kCANBus);

  //  private final int START_IDX = 8;
  //  private final int LED_COUNT = 30;
  // TODO: TA: Update LED Indexes
  private final int START_IDX = 0;
  private final int LED_COUNT = 8;

  // How many seconds left in match to start climber feedback
  // Set to 150.0 for practice to have it always active
  public static final double ENDGAME_THRESHOLD_SEC = 5.0;

  // Distance (meters) at which LEDs start turning Red -> White
  public static final double CLIMBER_PROXIMITY_THRESHOLD_METERS = 0.5;

  // How fast the Red -> White strobe blinks
  public static final double PROXIMITY_STROBE_HERTZ = 20.0;

  private ShooterSubsystem m_shooter;
  private Drive m_drive;
  private VisionSubsystem m_vision;

  // Shuffleboard entries
  private final ShuffleboardTab canTab = Shuffleboard.getTab("CAN Status");
  private final GenericEntry ledsActiveEntry;
  private final GenericEntry candLeCanOkEntry;

  // Pre-defined animations for states
  private final SingleFadeAnimation m_fadeOrange =
      new SingleFadeAnimation(START_IDX, LED_COUNT)
          .withColor(new RGBWColor(255, 50, 0, 0))
          .withFrameRate(Hertz.of(10));

  private final StrobeAnimation m_strobeWhite =
      new StrobeAnimation(START_IDX, LED_COUNT)
          .withColor(new RGBWColor(255, 255, 255, 255))
          .withFrameRate(Hertz.of(100));

  private final StrobeAnimation m_strobeGold =
      new StrobeAnimation(START_IDX, LED_COUNT)
          .withColor(new RGBWColor(255, 200, 0, 0))
          .withFrameRate(Hertz.of(500));

  private final SolidColor m_off =
      new SolidColor(START_IDX, LED_COUNT).withColor(new RGBWColor(0, 0, 0, 0));

  private boolean m_ledEnabled = true;

  public LEDSubsystem(ShooterSubsystem shooter, Drive drive, VisionSubsystem vision) {
    this.m_shooter = shooter;
    this.m_drive = drive;
    this.m_vision = vision;
  ledsActiveEntry =
    canTab.add("LEDs Active", m_ledEnabled)
      .withWidget(BuiltInWidgets.kBooleanBox)
      .withPosition(5, 5)
      .withSize(1, 1)
      .getEntry();
  candLeCanOkEntry =
    canTab.add("CANdle CAN OK", isCanDleConnected())
      .withWidget(BuiltInWidgets.kBooleanBox)
      .withPosition(6, 5)
      .withSize(1, 1)
      .getEntry();
  }

  public void toggleLeds() {
    m_ledEnabled = !m_ledEnabled;
  }

  @Override
  public void periodic() {
    // Priority 1: Kill Switch
    if (!m_ledEnabled) {
      m_candle.setControl(m_off);
      return;
    }

    // Priority 2: Disabled State
    if (DriverStation.isDisabled()) {
      m_candle.setControl(m_fadeOrange);
    } else {
      handleEnabledLogic();
    }

    // Update persistent entries
    ledsActiveEntry.setBoolean(m_ledEnabled);
    candLeCanOkEntry.setBoolean(isCanDleConnected());
  }

  private void handleEnabledLogic() {
    double matchTime = DriverStation.getMatchTime();

    // Priority 3: Endgame Climber Alignment (Last N seconds)
    if (matchTime > 0 && matchTime <= ENDGAME_THRESHOLD_SEC) {
      // Check distance to Tower Uprights
      double dist = getClimberDistance();

      if (dist < CLIMBER_PROXIMITY_THRESHOLD_METERS) { // N meter threshold
        // Calculate GB values to turn Red -> White
        double whiteRatio = Math.max(0, 1.0 - (dist / 0.5));
        int gbValue = (int) (255 * whiteRatio);

        m_candle.setControl(
            new StrobeAnimation(START_IDX, LED_COUNT)
                .withColor(new RGBWColor(255, gbValue, gbValue, 0))
                .withFrameRate(Hertz.of(20)));
        return; // Exit so we don't show shooter status
      }
    }

    // Priority 4: Shooter Feedback
    boolean flyOk = m_shooter.isFLywheelAtVelocity();
    boolean turretOk = m_shooter.isTurretAtPosition();
    boolean hoodOk = m_shooter.isHoodAtPosition();

    if (flyOk && turretOk && hoodOk) {

      if (m_vision.getTagCount() >= 3) {
        m_candle.setControl(m_strobeGold);
      } else {
        m_candle.setControl(m_strobeWhite);
      }

    } else {
      // RGB Mix: Red(Fly), Green(Hood), Blue(Turret)
      int r = flyOk ? 255 : 0;
      int g = hoodOk ? 255 : 0;
      int b = turretOk ? 255 : 0;
      m_candle.setControl(
          new SolidColor(START_IDX, LED_COUNT).withColor(new RGBWColor(r, g, b, 0)));
    }
  }

  /** Calculates distance from climber to the closest tower upright of your alliance */
  private double getClimberDistance() {
    // 2026 REBUILT Field Constants (Meters)
    final double FIELD_LENGTH = 16.54;
    final double FIELD_WIDTH_CENTER = 4.11; // Center of field width (Y)

    // Convert Inch Constants to Meters
    final double WALL_OFFSET = 43.25 * 0.0254; // 1.098m from Alliance Wall
    final double TOWER_Y_OFFSET = 11.42 * 0.0254; // 0.290m shift from center
    final double UPRIGHT_HALF_GAP = 16.125 * 0.0254; // Half of 32.25" gap (0.409m)

    // --- NEW: Climber Physical Offset (13" back, 5" left) ---// TODO: TA - final climber offset
    final double CLIMBER_X = -13.0 * 0.0254; // -0.3302m
    final double CLIMBER_Y = 5.0 * 0.0254; // 0.127m
    final Translation2d CLIMBER_OFFSET = new Translation2d(CLIMBER_X, CLIMBER_Y);

    var alliance = DriverStation.getAlliance().orElse(DriverStation.Alliance.Blue);
    boolean isRed = (alliance == DriverStation.Alliance.Red);

    // 1. Determine Tower Center (X and Y)
    // Blue: 45" in from Blue Wall, 11.42" LESS than center Y
    // Red: 45" in from Red Wall, 11.42" MORE than center Y
    double towerX = isRed ? (FIELD_LENGTH - WALL_OFFSET) : WALL_OFFSET;
    double towerY =
        isRed ? (FIELD_WIDTH_CENTER + TOWER_Y_OFFSET) : (FIELD_WIDTH_CENTER - TOWER_Y_OFFSET);

    // 2. Define Upright Positions (Left and Right relative to the Tower Center)
    final Translation2d LEFT_UPRIGHT = new Translation2d(towerX, towerY - UPRIGHT_HALF_GAP);
    final Translation2d RIGHT_UPRIGHT = new Translation2d(towerX, towerY + UPRIGHT_HALF_GAP);

    // 3. Calculate Climber Field Position
    // Rotate the climber's offset relative to the robot's heading then add to robot pose
    var robotPose = m_drive.getPose();
    var climberPos =
        robotPose.getTranslation().plus(CLIMBER_OFFSET.rotateBy(robotPose.getRotation()));

    // 4. Return distance to the closest upright of your alliance's tower
    return Math.min(climberPos.getDistance(LEFT_UPRIGHT), climberPos.getDistance(RIGHT_UPRIGHT));
  }

  public boolean isCanDleConnected() {
    return m_candle.getDeviceTemp().refresh().getStatus().isOK();
  }
}
